// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_progress.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getCourseProgressStats = `-- name: GetCourseProgressStats :one
SELECT
    COUNT(DISTINCT m.id) as total_modules,
    COUNT(DISTINCT ci.id) as total_items,
    COUNT(DISTINCT ci.id) FILTER (WHERE up.completed = true) as completed_items,
    MAX(up.last_accessed) as last_accessed
FROM modules m
LEFT JOIN content_items ci ON m.id = ci.module_id
LEFT JOIN user_progress up ON ci.id = up.content_item_id AND up.user_id = $2
WHERE m.course_id = $1
`

type GetCourseProgressStatsParams struct {
	CourseID uuid.UUID
	UserID   uuid.UUID
}

type GetCourseProgressStatsRow struct {
	TotalModules   int64
	TotalItems     int64
	CompletedItems int64
	LastAccessed   interface{}
}

func (q *Queries) GetCourseProgressStats(ctx context.Context, arg GetCourseProgressStatsParams) (GetCourseProgressStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseProgressStats, arg.CourseID, arg.UserID)
	var i GetCourseProgressStatsRow
	err := row.Scan(
		&i.TotalModules,
		&i.TotalItems,
		&i.CompletedItems,
		&i.LastAccessed,
	)
	return i, err
}

const getModuleProgressStats = `-- name: GetModuleProgressStats :one
SELECT
    COUNT(*) as total_items,
    COUNT(*) FILTER (WHERE up.completed = true) as completed_items,
    COALESCE(AVG(up.progress_pct), 0) as avg_progress
FROM content_items ci
LEFT JOIN user_progress up ON ci.id = up.content_item_id AND up.user_id = $2
WHERE ci.module_id = $1
`

type GetModuleProgressStatsParams struct {
	ModuleID uuid.UUID
	UserID   uuid.UUID
}

type GetModuleProgressStatsRow struct {
	TotalItems     int64
	CompletedItems int64
	AvgProgress    interface{}
}

func (q *Queries) GetModuleProgressStats(ctx context.Context, arg GetModuleProgressStatsParams) (GetModuleProgressStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getModuleProgressStats, arg.ModuleID, arg.UserID)
	var i GetModuleProgressStatsRow
	err := row.Scan(&i.TotalItems, &i.CompletedItems, &i.AvgProgress)
	return i, err
}

const getUserProgressByContentItem = `-- name: GetUserProgressByContentItem :one
SELECT id, user_id, content_item_id, completed, progress_pct, last_position, last_accessed, created_at, updated_at FROM user_progress
WHERE user_id = $1 AND content_item_id = $2
`

type GetUserProgressByContentItemParams struct {
	UserID        uuid.UUID
	ContentItemID uuid.UUID
}

func (q *Queries) GetUserProgressByContentItem(ctx context.Context, arg GetUserProgressByContentItemParams) (UserProgress, error) {
	row := q.db.QueryRowContext(ctx, getUserProgressByContentItem, arg.UserID, arg.ContentItemID)
	var i UserProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentItemID,
		&i.Completed,
		&i.ProgressPct,
		&i.LastPosition,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUserProgressByCourse = `-- name: ListUserProgressByCourse :many
SELECT up.id, up.user_id, up.content_item_id, up.completed, up.progress_pct, up.last_position, up.last_accessed, up.created_at, up.updated_at FROM user_progress up
JOIN content_items ci ON up.content_item_id = ci.id
JOIN modules m ON ci.module_id = m.id
WHERE m.course_id = $1 AND up.user_id = $2
ORDER BY m."order", ci."order"
`

type ListUserProgressByCourseParams struct {
	CourseID uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) ListUserProgressByCourse(ctx context.Context, arg ListUserProgressByCourseParams) ([]UserProgress, error) {
	rows, err := q.db.QueryContext(ctx, listUserProgressByCourse, arg.CourseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProgress
	for rows.Next() {
		var i UserProgress
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContentItemID,
			&i.Completed,
			&i.ProgressPct,
			&i.LastPosition,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertUserProgress = `-- name: UpsertUserProgress :one
INSERT INTO user_progress (
    id, user_id, content_item_id, completed, progress_pct, last_position, last_accessed, created_at, updated_at
) VALUES (
    gen_random_uuid(), $1, $2, $3, $4, $5, $6, now(), now()
)
ON CONFLICT (user_id, content_item_id)
DO UPDATE SET
    completed = EXCLUDED.completed,
    progress_pct = EXCLUDED.progress_pct,
    last_position = EXCLUDED.last_position,
    last_accessed = EXCLUDED.last_accessed,
    updated_at = now()
RETURNING id, user_id, content_item_id, completed, progress_pct, last_position, last_accessed, created_at, updated_at
`

type UpsertUserProgressParams struct {
	UserID        uuid.UUID
	ContentItemID uuid.UUID
	Completed     bool
	ProgressPct   float32
	LastPosition  sql.NullInt32
	LastAccessed  sql.NullTime
}

func (q *Queries) UpsertUserProgress(ctx context.Context, arg UpsertUserProgressParams) (UserProgress, error) {
	row := q.db.QueryRowContext(ctx, upsertUserProgress,
		arg.UserID,
		arg.ContentItemID,
		arg.Completed,
		arg.ProgressPct,
		arg.LastPosition,
		arg.LastAccessed,
	)
	var i UserProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentItemID,
		&i.Completed,
		&i.ProgressPct,
		&i.LastPosition,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
